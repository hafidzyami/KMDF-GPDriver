// ============= FIXED VERSIONS OF FUNCTIONS =============

// 1. Fixed GetImageLoadHistory - Resolves Warning C6101
ULONG
ImageFilter::GetImageLoadHistory(
	_In_ HANDLE ProcessId,
	_Out_ PIMAGE_LOAD_INFO ImageLoadInfoArray,
	_In_ ULONG MaxEntries)
{
	// Initialize variables
	PROCESS_HISTORY_ENTRY currentProcessHistory = {0}; // Initialize to prevent warning
	PIMAGE_LOAD_HISTORY_ENTRY currentImageEntry = NULL;
	ULONG entryCount = 0;

	// Always initialize output array first to prevent C6101 warning
	if (ImageLoadInfoArray != NULL && MaxEntries > 0) {
		RtlZeroMemory(ImageLoadInfoArray, MaxEntries * sizeof(IMAGE_LOAD_INFO));
	}
	
	// Early exit if parameters aren't valid - but the array is already initialized
	if (ImageFilter::destroying || MaxEntries == 0 || ImageLoadInfoArray == NULL)
	{
		return 0;
	}

	// Rest of the function remains the same...

// 2. Fixed ThreadNotifyRoutine - Resolves Warning C6001
VOID ImageFilter::ThreadNotifyRoutine(
	_In_ HANDLE ProcessId,
	_In_ HANDLE ThreadId,
	_In_ BOOLEAN Create)
{
	ULONG processThreadCount = 0;
	PVOID threadStartAddress = NULL;
	PSTACK_RETURN_INFO threadCreateStack = NULL;
	ULONG threadCreateStackSize = 20;
	PUNICODE_STRING threadCallerName = NULL;
	PUNICODE_STRING threadTargetName = NULL;

	// Initialize explicitly
	threadStartAddress = NULL;

	//
	// We don't really care about thread termination or if the thread is kernel-mode.
	//
	if (Create == FALSE || ExGetPreviousMode() == KernelMode)
	{
		return;
	}

	//
	// If we can't find the process or it's the first thread of the process, skip it.
	//
	if (ImageFilter::AddProcessThreadCount(ProcessId, &processThreadCount) == FALSE ||
		processThreadCount <= 1)
	{
		return;
	}

	//
	// Walk the stack.
	//
	ImageFilter::walker.WalkAndResolveStack(&threadCreateStack, &threadCreateStackSize, STACK_HISTORY_TAG);
	// Continue even if stack walk fails
	if (threadCreateStack == NULL) {
		DBGPRINT("ImageFilter!ThreadNotifyRoutine: Failed to walk the stack, continuing without stack info.");
		threadCreateStackSize = 0;
	}

	//
	// Grab the name of the caller.
	//
	threadCallerName = NULL; // Initialize to NULL first to fix warning C6001
	if (ImageFilter::GetProcessImageFileName(PsGetCurrentProcessId(), &threadCallerName) == FALSE)
	{
		// Already initialized to NULL above
		goto Exit;
	}

	threadTargetName = threadCallerName;

	//
	// We only need to resolve again if the target process is a different than the caller.
	//
	if (PsGetCurrentProcessId() != ProcessId)
	{
		//
		// Grab the name of the target.
		//
		if (ImageFilter::GetProcessImageFileName(ProcessId, &threadTargetName) == FALSE)
		{
			goto Exit;
		}
	}

	//
	// Grab the start address of the thread.
	//
	threadStartAddress = ImageFilter::GetThreadStartAddress(ThreadId);

	// Only perform audits if we actually have stack information
	if (threadCreateStack != NULL && threadCreateStackSize > 0) {
		//
		// Audit the target's start address.
		//
		ImageFilter::detector->AuditUserPointer(ThreadCreate, threadStartAddress, PsGetCurrentProcessId(), threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);

		//
		// Audit the caller's stack.
		//
		ImageFilter::detector->AuditUserStackWalk(ThreadCreate, PsGetCurrentProcessId(), threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);

		//
		// Check if this is a remote operation.
		//
		ImageFilter::detector->AuditCallerProcessId(ThreadCreate, PsGetCurrentProcessId(), ProcessId, threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);
	}
Exit:
	if (threadCreateStack != NULL)
	{
		ExFreePoolWithTag(threadCreateStack, STACK_HISTORY_TAG);
	}
	if (threadCallerName != NULL)
	{
		ExFreePoolWithTag(threadCallerName, IMAGE_NAME_TAG);
	}
	if (threadCallerName != threadTargetName && threadTargetName != NULL)
	{
		ExFreePoolWithTag(threadTargetName, IMAGE_NAME_TAG);
	}
}

// 3. Fixed StackWalker::WalkAndResolveStack - Resolves Warning C4701
VOID
StackWalker::WalkAndResolveStack (
	_Inout_ PSTACK_RETURN_INFO* ResolvedStack,
	_Inout_ ULONG* ResolvedStackSize,
	_In_ ULONG ResolvedStackTag
	)
{
	PVOID* stackReturnPtrs = NULL; // Initialize to NULL to fix warning C4701
	ULONG capturedReturnPtrs = 0;
	ULONG i = 0;
	
	capturedReturnPtrs = 0;
	*ResolvedStack = NULL;

	// Check if we're at an IRQL too high for safe memory operations
	if (KeGetCurrentIrql() > PASSIVE_LEVEL) {
		DBGPRINT("StackWalker!WalkAndResolveStack: IRQL too high (%d) for stack walking", KeGetCurrentIrql());
		goto Exit;
	}

	// The rest of the function remains the same...
